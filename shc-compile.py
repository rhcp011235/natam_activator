#!/usr/bin/env python3
"""
SHC-like Shell Script Compiler
Compiles bash scripts into encrypted standalone executables.

Usage: ./shc-compile.py <script.sh> [-o output] [-s shell] [-e expiry_date]

Author: Custom implementation based on SHC reverse engineering
"""

import argparse
import os
import random
import subprocess
import sys
import tempfile
from datetime import datetime

def rc4_encrypt(key: bytes, data: bytes) -> bytes:
    """RC4 encryption"""
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]

    i = j = 0
    result = bytearray()
    for byte in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        k = S[(S[i] + S[j]) % 256]
        result.append(byte ^ k)
    return bytes(result)

def generate_key(length: int = 256) -> bytes:
    """Generate a random encryption key"""
    return bytes(random.randint(0, 255) for _ in range(length))

def bytes_to_c_array(data: bytes, name: str) -> str:
    """Convert bytes to C array declaration"""
    lines = [f"static unsigned char {name}[] = {{"]
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_values = ", ".join(f"0x{b:02x}" for b in chunk)
        lines.append(f"    {hex_values},")
    lines.append("};")
    return "\n".join(lines)

def generate_c_code(encrypted_script: bytes, key: bytes, shell: str,
                    expiry_timestamp: int = 0, expiry_msg: str = "") -> str:
    """Generate the C source code for the compiled binary"""

    script_array = bytes_to_c_array(encrypted_script, "encrypted_script")
    key_array = bytes_to_c_array(key, "rc4_key")

    c_code = f'''/*
 * Compiled Shell Script
 * Generated by shc-compile.py
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>

#define SCRIPT_SIZE {len(encrypted_script)}
#define KEY_SIZE {len(key)}
#define SHELL "{shell}"
#define EXPIRY_TIME {expiry_timestamp}L

{key_array}

{script_array}

static const char *expiry_message = "{expiry_msg}";

/* RC4 decryption */
void rc4_decrypt(unsigned char *key, int key_len, unsigned char *data, int data_len) {{
    unsigned char S[256];
    int i, j = 0;
    unsigned char tmp;

    /* Key Scheduling Algorithm (KSA) */
    for (i = 0; i < 256; i++) {{
        S[i] = i;
    }}

    for (i = 0; i < 256; i++) {{
        j = (j + S[i] + key[i % key_len]) % 256;
        tmp = S[i];
        S[i] = S[j];
        S[j] = tmp;
    }}

    /* Pseudo-Random Generation Algorithm (PRGA) */
    i = j = 0;
    for (int k = 0; k < data_len; k++) {{
        i = (i + 1) % 256;
        j = (j + S[i]) % 256;
        tmp = S[i];
        S[i] = S[j];
        S[j] = tmp;
        data[k] ^= S[(S[i] + S[j]) % 256];
    }}
}}

/* Clear sensitive data from memory */
void secure_clear(void *ptr, size_t len) {{
    volatile unsigned char *p = ptr;
    while (len--) {{
        *p++ = 0;
    }}
}}

int main(int argc, char *argv[]) {{
    /* Check expiry */
    if (EXPIRY_TIME > 0 && time(NULL) > EXPIRY_TIME) {{
        fprintf(stderr, "This program %s\\n", expiry_message);
        return 1;
    }}

    /* Allocate buffer for decrypted script */
    unsigned char *script = malloc(SCRIPT_SIZE + 1);
    if (!script) {{
        fprintf(stderr, "Memory allocation failed\\n");
        return 1;
    }}

    /* Copy encrypted data */
    memcpy(script, encrypted_script, SCRIPT_SIZE);

    /* Make a copy of the key (RC4 modifies state) */
    unsigned char key_copy[KEY_SIZE];
    memcpy(key_copy, rc4_key, KEY_SIZE);

    /* Decrypt the script */
    rc4_decrypt(key_copy, KEY_SIZE, script, SCRIPT_SIZE);
    script[SCRIPT_SIZE] = '\\0';

    /* Clear key from memory */
    secure_clear(key_copy, KEY_SIZE);

    /* Build argv for execvp */
    char **new_argv = malloc((argc + 4) * sizeof(char *));
    if (!new_argv) {{
        secure_clear(script, SCRIPT_SIZE);
        free(script);
        fprintf(stderr, "Memory allocation failed\\n");
        return 1;
    }}

    new_argv[0] = SHELL;
    new_argv[1] = "-c";
    new_argv[2] = (char *)script;
    new_argv[3] = argv[0];  /* Script name as $0 */

    /* Pass through original arguments as $1, $2, etc */
    for (int i = 1; i < argc; i++) {{
        new_argv[i + 3] = argv[i];
    }}
    new_argv[argc + 3] = NULL;

    /* Execute the script */
    execvp(SHELL, new_argv);

    /* If execvp returns, it failed */
    perror("execvp failed");
    secure_clear(script, SCRIPT_SIZE);
    free(script);
    free(new_argv);
    return 1;
}}
'''
    return c_code

def compile_binary(c_code: str, output_path: str) -> bool:
    """Compile the C code into a binary"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(c_code)
        c_file = f.name

    try:
        # Try to compile with optimizations and strip symbols
        result = subprocess.run(
            ['cc', '-O2', '-o', output_path, c_file, '-s'],
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            # Try without -s flag (some systems don't support it)
            result = subprocess.run(
                ['cc', '-O2', '-o', output_path, c_file],
                capture_output=True,
                text=True
            )

        if result.returncode != 0:
            print(f"Compilation error: {result.stderr}", file=sys.stderr)
            return False

        # Make executable
        os.chmod(output_path, 0o755)

        # Try to strip symbols separately
        subprocess.run(['strip', output_path], capture_output=True)

        return True
    finally:
        os.unlink(c_file)

def main():
    parser = argparse.ArgumentParser(
        description='Compile bash scripts into encrypted executables',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s script.sh                    # Creates script.sh.x
  %(prog)s script.sh -o myprogram       # Creates myprogram
  %(prog)s script.sh -e 2025-12-31      # Set expiry date
  %(prog)s script.sh -s /bin/zsh        # Use zsh instead of bash
        '''
    )
    parser.add_argument('script', help='Shell script to compile')
    parser.add_argument('-o', '--output', help='Output binary name (default: <script>.x)')
    parser.add_argument('-s', '--shell', default='/bin/bash', help='Shell to use (default: /bin/bash)')
    parser.add_argument('-e', '--expiry', help='Expiry date (YYYY-MM-DD format)')
    parser.add_argument('-m', '--message', default='has expired!', help='Expiry message')
    parser.add_argument('-k', '--keep-source', action='store_true', help='Keep generated C source file')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')

    args = parser.parse_args()

    # Check input file
    if not os.path.isfile(args.script):
        print(f"Error: Script file '{args.script}' not found", file=sys.stderr)
        return 1

    # Read script
    with open(args.script, 'rb') as f:
        script_data = f.read()

    if args.verbose:
        print(f"[*] Input script: {args.script} ({len(script_data)} bytes)")

    # Generate key
    key = generate_key(256)
    if args.verbose:
        print(f"[*] Generated {len(key)}-byte encryption key")

    # Encrypt script
    encrypted = rc4_encrypt(key, script_data)
    if args.verbose:
        print(f"[*] Encrypted script: {len(encrypted)} bytes")

    # Parse expiry date
    expiry_timestamp = 0
    if args.expiry:
        try:
            expiry_date = datetime.strptime(args.expiry, '%Y-%m-%d')
            expiry_timestamp = int(expiry_date.timestamp())
            if args.verbose:
                print(f"[*] Expiry set to: {args.expiry}")
        except ValueError:
            print(f"Error: Invalid date format. Use YYYY-MM-DD", file=sys.stderr)
            return 1

    # Generate C code
    c_code = generate_c_code(encrypted, key, args.shell, expiry_timestamp, args.message)
    if args.verbose:
        print(f"[*] Generated C source: {len(c_code)} bytes")

    # Determine output path
    output_path = args.output or f"{args.script}.x"

    # Optionally save C source
    if args.keep_source:
        c_source_path = f"{output_path}.c"
        with open(c_source_path, 'w') as f:
            f.write(c_code)
        print(f"[+] Saved C source: {c_source_path}")

    # Compile
    if args.verbose:
        print(f"[*] Compiling binary...")

    if compile_binary(c_code, output_path):
        file_size = os.path.getsize(output_path)
        print(f"[+] Successfully created: {output_path} ({file_size} bytes)")
        return 0
    else:
        print(f"[-] Compilation failed", file=sys.stderr)
        return 1

if __name__ == '__main__':
    sys.exit(main())
